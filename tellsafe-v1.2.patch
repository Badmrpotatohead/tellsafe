diff -ruN '--exclude=node_modules' '--exclude=.next' '--exclude=package-lock.json' a/app/admin/page.tsx b/app/admin/page.tsx
--- a/app/admin/page.tsx	2026-02-18 17:41:38.000000000 +0000
+++ b/app/admin/page.tsx	2026-02-18 23:25:51.000000000 +0000
@@ -16,6 +16,7 @@
 import BrandingSettings from "../../components/BrandingSettings";
 import TemplatesManager from "../../components/TemplatesManager";
 import QRCodeGenerator from "../../components/QRCodeGenerator";
+import AnalyticsDashboard from "../../components/AnalyticsDashboard";
 import type { AdminView } from "../../components/AdminSidebar";
 
 const fontStack = "'Outfit', system-ui, sans-serif";
@@ -156,6 +157,39 @@
 
   const orgId = org.id;
 
+  const handleExportCsv = async () => {
+    try {
+      const { getAuth } = await import("firebase/auth");
+      const token = await getAuth().currentUser?.getIdToken();
+      if (!token) return alert("Please sign in to export.");
+
+      const res = await fetch(`/api/export?orgId=${orgId}`, {
+        headers: { Authorization: `Bearer ${token}` },
+      });
+
+      if (!res.ok) {
+        const data = await res.json().catch(() => ({}));
+        return alert(data.error || "Export failed");
+      }
+
+      // Trigger download
+      const blob = await res.blob();
+      const url = URL.createObjectURL(blob);
+      const a = document.createElement("a");
+      a.href = url;
+      a.download =
+        res.headers.get("Content-Disposition")?.split("filename=")[1]?.replace(/"/g, "") ||
+        "tellsafe-export.csv";
+      document.body.appendChild(a);
+      a.click();
+      document.body.removeChild(a);
+      URL.revokeObjectURL(url);
+    } catch (err) {
+      console.error("Export failed:", err);
+      alert("Export failed. Please try again.");
+    }
+  };
+
   const openThread = (tid: string, fid: string) => {
     setThreadId(tid);
     setThreadFeedbackId(fid);
@@ -267,6 +301,7 @@
                   </button>
                 )}
                 <button
+                  onClick={handleExportCsv}
                   style={{
                     padding: "7px 16px",
                     border: "1.5px solid rgba(26,26,46,0.10)",
@@ -279,7 +314,7 @@
                     fontFamily: fontStack,
                   }}
                 >
-                  üì§ Export
+                  üì§ Export CSV
                 </button>
                 <button
                   style={{
@@ -343,6 +378,9 @@
           </div>
         );
 
+      case "analytics":
+        return <AnalyticsDashboard orgId={orgId} />;
+
       default:
         return null;
     }
diff -ruN '--exclude=node_modules' '--exclude=.next' '--exclude=package-lock.json' a/app/api/export/route.ts b/app/api/export/route.ts
--- a/app/api/export/route.ts	1970-01-01 00:00:00.000000000 +0000
+++ b/app/api/export/route.ts	2026-02-18 23:23:57.000000000 +0000
@@ -0,0 +1,154 @@
+// ============================================================
+// TellSafe v1.2 ‚Äî CSV Export API Route
+// ============================================================
+// Exports feedback data as a CSV file for download.
+// Pro plan feature ‚Äî gated on the client side.
+// Requires auth token in Authorization header.
+
+import { NextRequest, NextResponse } from "next/server";
+import { adminAuth, adminCollections } from "../../../lib/firebase-admin";
+import type { Feedback, Organization } from "../../../types";
+
+export async function GET(request: NextRequest) {
+  try {
+    // --- Auth check ---
+    const authHeader = request.headers.get("Authorization");
+    if (!authHeader?.startsWith("Bearer ")) {
+      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
+    }
+
+    const token = authHeader.split("Bearer ")[1];
+    let uid: string;
+    try {
+      const decoded = await adminAuth.verifyIdToken(token);
+      uid = decoded.uid;
+    } catch {
+      return NextResponse.json({ error: "Invalid token" }, { status: 401 });
+    }
+
+    // --- Get orgId from query ---
+    const orgId = request.nextUrl.searchParams.get("orgId");
+    if (!orgId) {
+      return NextResponse.json(
+        { error: "orgId is required" },
+        { status: 400 }
+      );
+    }
+
+    // --- Verify user is admin of this org ---
+    const adminDoc = await adminCollections.admins(orgId).doc(uid).get();
+    if (!adminDoc.exists) {
+      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
+    }
+
+    // --- Optional filters ---
+    const statusFilter = request.nextUrl.searchParams.get("status");
+    const categoryFilter = request.nextUrl.searchParams.get("category");
+    const sentimentFilter = request.nextUrl.searchParams.get("sentiment");
+    const fromDate = request.nextUrl.searchParams.get("from");
+    const toDate = request.nextUrl.searchParams.get("to");
+
+    // --- Fetch feedback ---
+    let query: FirebaseFirestore.Query = adminCollections
+      .feedback(orgId)
+      .orderBy("createdAt", "desc");
+
+    if (statusFilter) {
+      query = query.where("status", "==", statusFilter);
+    }
+    if (sentimentFilter) {
+      query = query.where("sentimentLabel", "==", sentimentFilter);
+    }
+
+    const snap = await query.get();
+    let items = snap.docs.map((doc) => ({
+      id: doc.id,
+      ...doc.data(),
+    })) as Feedback[];
+
+    // Client-side filters (Firestore limitations on compound queries)
+    if (categoryFilter) {
+      items = items.filter((f) => f.categories.includes(categoryFilter));
+    }
+    if (fromDate) {
+      items = items.filter((f) => f.createdAt >= fromDate);
+    }
+    if (toDate) {
+      items = items.filter((f) => f.createdAt <= toDate);
+    }
+
+    // --- Get org name for filename ---
+    const orgSnap = await adminCollections.organization(orgId).get();
+    const orgName = orgSnap.exists
+      ? (orgSnap.data() as Organization).name
+      : "export";
+    const safeOrgName = orgName.replace(/[^a-zA-Z0-9]/g, "-").toLowerCase();
+
+    // --- Build CSV ---
+    const headers = [
+      "ID",
+      "Date",
+      "Type",
+      "Status",
+      "Categories",
+      "Feedback Text",
+      "Sentiment",
+      "Sentiment Score",
+      "Author Name",
+      "Author Email",
+    ];
+
+    const rows = items.map((f) => {
+      const date = new Date(f.createdAt).toLocaleString("en-US", {
+        timeZone: "America/New_York",
+      });
+      const cats = f.categories.join("; ");
+      const authorName =
+        f.type === "identified" && "authorName" in f
+          ? (f as any).authorName
+          : "";
+      const authorEmail =
+        f.type === "identified" && "authorEmail" in f
+          ? (f as any).authorEmail
+          : "";
+
+      return [
+        f.id,
+        date,
+        f.type,
+        f.status,
+        cats,
+        f.text,
+        f.sentimentLabel || "unanalyzed",
+        f.sentimentScore !== null ? f.sentimentScore.toString() : "",
+        authorName,
+        authorEmail,
+      ];
+    });
+
+    const csvContent = [
+      headers.join(","),
+      ...rows.map((row) =>
+        row.map((cell) => `"${String(cell).replace(/"/g, '""')}"`).join(",")
+      ),
+    ].join("\n");
+
+    // --- Return CSV ---
+    const dateStr = new Date().toISOString().split("T")[0];
+    const filename = `tellsafe-${safeOrgName}-${dateStr}.csv`;
+
+    return new NextResponse(csvContent, {
+      status: 200,
+      headers: {
+        "Content-Type": "text/csv; charset=utf-8",
+        "Content-Disposition": `attachment; filename="${filename}"`,
+      },
+    });
+  } catch (err) {
+    console.error("CSV export error:", err);
+    return NextResponse.json(
+      { error: "Internal server error" },
+      { status: 500 }
+    );
+  }
+}
diff -ruN '--exclude=node_modules' '--exclude=.next' '--exclude=package-lock.json' a/app/api/feedback/route.ts b/app/api/feedback/route.ts
--- a/app/api/feedback/route.ts	1970-01-01 00:00:00.000000000 +0000
+++ b/app/api/feedback/route.ts	2026-02-18 23:23:39.000000000 +0000
@@ -0,0 +1,210 @@
+// ============================================================
+// TellSafe v1.2 ‚Äî Feedback Submission API Route
+// ============================================================
+// Handles feedback submission server-side so we can:
+// 1. Run sentiment analysis (Claude API ‚Äî server-only)
+// 2. Encrypt relay emails (server-only)
+// 3. Send email notifications to admins (SendGrid ‚Äî server-only)
+// 4. Enforce submission limits
+
+import { NextRequest, NextResponse } from "next/server";
+import { adminDb, adminCollections } from "../../../lib/firebase-admin";
+import { analyzeSentiment } from "../../../lib/sentiment";
+import { encryptEmail } from "../../../lib/encryption";
+import {
+  sendRelayConfirmation,
+  sendNewFeedbackNotification,
+} from "../../../lib/sendgrid";
+import type {
+  Organization,
+  Plan,
+  FeedbackStatus,
+  SubmitFeedbackRequest,
+} from "../../../types";
+import { PLAN_LIMITS } from "../../../types";
+import { FieldValue } from "firebase-admin/firestore";
+
+export async function POST(request: NextRequest) {
+  try {
+    const body = (await request.json()) as SubmitFeedbackRequest & {
+      orgId: string;
+    };
+
+    const { orgId, type, categories, text, authorName, authorEmail, relayEmail } =
+      body;
+
+    // --- Validate ---
+    if (!orgId || !type || !text?.trim()) {
+      return NextResponse.json(
+        { error: "Missing required fields" },
+        { status: 400 }
+      );
+    }
+
+    // --- Get org ---
+    const orgSnap = await adminCollections.organization(orgId).get();
+    if (!orgSnap.exists) {
+      return NextResponse.json(
+        { error: "Organization not found" },
+        { status: 404 }
+      );
+    }
+    const org = { id: orgSnap.id, ...orgSnap.data() } as Organization;
+
+    // --- Check submission limits ---
+    const limits = PLAN_LIMITS[org.plan];
+    if (
+      limits.maxSubmissionsPerMonth !== Infinity &&
+      org.submissionCount >= limits.maxSubmissionsPerMonth
+    ) {
+      return NextResponse.json(
+        { error: "This organization has reached its monthly submission limit." },
+        { status: 429 }
+      );
+    }
+
+    // --- Check relay is allowed ---
+    if (type === "relay" && !limits.hasRelay) {
+      return NextResponse.json(
+        { error: "Anonymous relay is not available on the free plan." },
+        { status: 403 }
+      );
+    }
+
+    const now = new Date().toISOString();
+
+    // --- Build feedback document ---
+    const feedbackData: Record<string, any> = {
+      type,
+      categories: categories || [],
+      text: text.trim(),
+      status: "new" as FeedbackStatus,
+      sentimentScore: null,
+      sentimentLabel: null,
+      createdAt: now,
+      updatedAt: now,
+    };
+
+    if (type === "identified") {
+      feedbackData.authorName = authorName || "";
+      feedbackData.authorEmail = authorEmail || "";
+    }
+
+    // --- Relay: encrypt email + create thread ---
+    let threadId: string | undefined;
+
+    if (type === "relay" && relayEmail) {
+      const encrypted = encryptEmail(relayEmail);
+      feedbackData.encryptedEmail = encrypted;
+      feedbackData.status = "needs_reply";
+
+      // Create relay thread
+      const threadRef = adminCollections.threads(orgId).doc();
+      threadId = threadRef.id;
+
+      await threadRef.set({
+        feedbackId: "", // will update after feedback doc is created
+        status: "active",
+        messageCount: 1,
+        lastMessageAt: now,
+        createdAt: now,
+      });
+
+      feedbackData.threadId = threadId;
+    }
+
+    // --- Run sentiment analysis (all plans in v1.2 ‚Äî basic labeling is free, detailed scores are Pro) ---
+    try {
+      const sentiment = await analyzeSentiment(
+        text.trim(),
+        categories?.[0] || "General"
+      );
+      feedbackData.sentimentScore = sentiment.score;
+      feedbackData.sentimentLabel = sentiment.label;
+
+      // Auto-escalate urgent feedback
+      if (sentiment.label === "urgent") {
+        feedbackData.status = "needs_reply";
+      }
+    } catch (err) {
+      console.error("Sentiment analysis failed (non-blocking):", err);
+    }
+
+    // --- Write feedback to Firestore ---
+    const feedbackRef = await adminCollections.feedback(orgId).add(feedbackData);
+    const feedbackId = feedbackRef.id;
+
+    // --- Update thread with feedbackId ---
+    if (threadId) {
+      await adminCollections.thread(orgId, threadId).update({
+        feedbackId,
+      });
+
+      // Add initial message to thread
+      await adminCollections.messages(orgId, threadId).add({
+        from: "member",
+        authorName: null,
+        text: text.trim(),
+        createdAt: now,
+      });
+
+      // Send relay confirmation email
+      try {
+        await sendRelayConfirmation({
+          memberEmail: relayEmail!,
+          orgName: org.name,
+          threadId,
+        });
+      } catch (err) {
+        console.error("Relay confirmation email failed:", err);
+      }
+    }
+
+    // --- Increment submission count ---
+    await adminCollections.organization(orgId).update({
+      submissionCount: FieldValue.increment(1),
+    });
+
+    // --- Notify admins via email ---
+    try {
+      const adminsSnap = await adminCollections.admins(orgId).get();
+      const adminEmails = adminsSnap.docs
+        .map((d) => d.data().email)
+        .filter(Boolean) as string[];
+
+      if (adminEmails.length > 0) {
+        const appUrl =
+          process.env.NEXT_PUBLIC_APP_URL || "https://tellsafe.vercel.app";
+
+        await sendNewFeedbackNotification({
+          adminEmails,
+          orgName: org.name,
+          feedbackType: type,
+          category: categories?.[0] || "General",
+          previewText: text.trim().substring(0, 150),
+          dashboardUrl: `${appUrl}/admin`,
+        });
+      }
+    } catch (err) {
+      console.error("Admin notification email failed:", err);
+    }
+
+    return NextResponse.json({
+      success: true,
+      feedbackId,
+      threadId,
+      sentiment: feedbackData.sentimentLabel
+        ? {
+            label: feedbackData.sentimentLabel,
+            score: feedbackData.sentimentScore,
+          }
+        : null,
+    });
+  } catch (err) {
+    console.error("Feedback submission error:", err);
+    return NextResponse.json(
+      { error: "Internal server error" },
+      { status: 500 }
+    );
+  }
+}
diff -ruN '--exclude=node_modules' '--exclude=.next' '--exclude=package-lock.json' a/components/AdminSidebar.tsx b/components/AdminSidebar.tsx
--- a/components/AdminSidebar.tsx	2026-02-18 17:41:38.000000000 +0000
+++ b/components/AdminSidebar.tsx	2026-02-18 23:25:25.000000000 +0000
@@ -14,7 +14,7 @@
 const monoFont = "'JetBrains Mono', monospace";
 const fontStack = "'Outfit', system-ui, sans-serif";
 
-type AdminView = "inbox" | "needs_reply" | "resolved" | "branding" | "team" | "qr" | "templates";
+type AdminView = "inbox" | "needs_reply" | "resolved" | "branding" | "team" | "qr" | "templates" | "analytics";
 
 interface Props {
   orgId: string;
@@ -73,6 +73,7 @@
       active: activeCategory === c.label,
     })),
     { sep: true },
+    { icon: "üìä", label: "Analytics", view: "analytics" as AdminView, active: activeView === "analytics" },
     { icon: "üé®", label: "Branding", view: "branding" as AdminView, active: activeView === "branding" },
     { icon: "üìã", label: "Templates", view: "templates" as AdminView, active: activeView === "templates" },
     { icon: "üë•", label: "Team Access", view: "team" as AdminView, active: activeView === "team" },
diff -ruN '--exclude=node_modules' '--exclude=.next' '--exclude=package-lock.json' a/components/AnalyticsDashboard.tsx b/components/AnalyticsDashboard.tsx
--- a/components/AnalyticsDashboard.tsx	1970-01-01 00:00:00.000000000 +0000
+++ b/components/AnalyticsDashboard.tsx	2026-02-18 23:24:59.000000000 +0000
@@ -0,0 +1,494 @@
+// ============================================================
+// TellSafe v1.2 ‚Äî Analytics Dashboard
+// ============================================================
+// Comprehensive analytics view with:
+// - Submission trend (last 30 days)
+// - Sentiment breakdown (pie/donut style)
+// - Category distribution
+// - Privacy type breakdown
+// - Response time stats
+
+"use client";
+
+import React, { useState, useEffect, useMemo } from "react";
+import { useBrand } from "./BrandProvider";
+import { subscribeFeedback } from "../lib/data";
+import type { Feedback } from "../types";
+
+const fontStack = "'Outfit', system-ui, sans-serif";
+const displayFont = "'Fraunces', Georgia, serif";
+
+interface Props {
+  orgId: string;
+}
+
+// --- Helpers ---
+function getDaysAgo(n: number): Date {
+  const d = new Date();
+  d.setDate(d.getDate() - n);
+  d.setHours(0, 0, 0, 0);
+  return d;
+}
+
+function formatDate(d: Date): string {
+  return `${d.getMonth() + 1}/${d.getDate()}`;
+}
+
+function getWeekLabel(d: Date): string {
+  const month = d.toLocaleString("en", { month: "short" });
+  return `${month} ${d.getDate()}`;
+}
+
+export default function AnalyticsDashboard({ orgId }: Props) {
+  const { theme } = useBrand();
+  const [feedback, setFeedback] = useState<Feedback[]>([]);
+  const [timeRange, setTimeRange] = useState<"7d" | "30d" | "90d" | "all">("30d");
+  const [loading, setLoading] = useState(true);
+
+  useEffect(() => {
+    const unsub = subscribeFeedback(orgId, {}, (items) => {
+      setFeedback(items);
+      setLoading(false);
+    });
+    return () => unsub();
+  }, [orgId]);
+
+  // --- Filter by time range ---
+  const filtered = useMemo(() => {
+    if (timeRange === "all") return feedback;
+    const days = timeRange === "7d" ? 7 : timeRange === "30d" ? 30 : 90;
+    const cutoff = getDaysAgo(days).toISOString();
+    return feedback.filter((f) => f.createdAt >= cutoff);
+  }, [feedback, timeRange]);
+
+  // --- Compute stats ---
+  const stats = useMemo(() => {
+    const total = filtered.length;
+    const byStatus = {
+      new: filtered.filter((f) => f.status === "new").length,
+      needs_reply: filtered.filter((f) => f.status === "needs_reply").length,
+      replied: filtered.filter((f) => f.status === "replied").length,
+      resolved: filtered.filter((f) => f.status === "resolved").length,
+    };
+    const bySentiment = {
+      positive: filtered.filter((f) => f.sentimentLabel === "positive").length,
+      neutral: filtered.filter((f) => f.sentimentLabel === "neutral").length,
+      negative: filtered.filter((f) => f.sentimentLabel === "negative").length,
+      urgent: filtered.filter((f) => f.sentimentLabel === "urgent").length,
+      unanalyzed: filtered.filter((f) => !f.sentimentLabel).length,
+    };
+    const byType = {
+      identified: filtered.filter((f) => f.type === "identified").length,
+      anonymous: filtered.filter((f) => f.type === "anonymous").length,
+      relay: filtered.filter((f) => f.type === "relay").length,
+    };
+    const byCategory: Record<string, number> = {};
+    filtered.forEach((f) =>
+      f.categories.forEach((c) => {
+        byCategory[c] = (byCategory[c] || 0) + 1;
+      })
+    );
+
+    // Resolution rate
+    const closedCount = byStatus.resolved + byStatus.replied;
+    const resolutionRate = total > 0 ? Math.round((closedCount / total) * 100) : 0;
+
+    // Avg sentiment score
+    const scored = filtered.filter((f) => f.sentimentScore !== null);
+    const avgSentiment =
+      scored.length > 0
+        ? scored.reduce((s, f) => s + (f.sentimentScore || 0), 0) / scored.length
+        : null;
+
+    return { total, byStatus, bySentiment, byType, byCategory, resolutionRate, avgSentiment };
+  }, [filtered]);
+
+  // --- Trend data (daily counts) ---
+  const trendData = useMemo(() => {
+    const days = timeRange === "7d" ? 7 : timeRange === "30d" ? 30 : timeRange === "90d" ? 90 : 60;
+    const data: { date: Date; label: string; count: number; sentiment: number }[] = [];
+
+    for (let i = days - 1; i >= 0; i--) {
+      const dayStart = getDaysAgo(i);
+      const dayEnd = new Date(dayStart);
+      dayEnd.setDate(dayEnd.getDate() + 1);
+
+      const dayItems = feedback.filter((f) => {
+        const d = new Date(f.createdAt);
+        return d >= dayStart && d < dayEnd;
+      });
+
+      const scored = dayItems.filter((f) => f.sentimentScore !== null);
+      const avgScore =
+        scored.length > 0
+          ? scored.reduce((s, f) => s + (f.sentimentScore || 0), 0) / scored.length
+          : 0;
+
+      data.push({
+        date: dayStart,
+        label: formatDate(dayStart),
+        count: dayItems.length,
+        sentiment: avgScore,
+      });
+    }
+    return data;
+  }, [feedback, timeRange]);
+
+  const maxCount = Math.max(...trendData.map((d) => d.count), 1);
+
+  if (loading) {
+    return (
+      <div style={{ padding: 28, fontFamily: fontStack }}>
+        <div style={{ height: 400, display: "flex", alignItems: "center", justifyContent: "center", color: theme.muted }}>
+          Loading analytics...
+        </div>
+      </div>
+    );
+  }
+
+  const sentimentColors: Record<string, string> = {
+    positive: "#059669",
+    neutral: "#8a8578",
+    negative: "#d97706",
+    urgent: "#dc2626",
+    unanalyzed: "#d4d0c8",
+  };
+
+  const typeColors: Record<string, string> = {
+    identified: theme.accent,
+    anonymous: theme.primary,
+    relay: theme.violet,
+  };
+
+  // Sentiment donut segments
+  const sentimentTotal =
+    stats.bySentiment.positive +
+    stats.bySentiment.neutral +
+    stats.bySentiment.negative +
+    stats.bySentiment.urgent;
+  const sentimentSegments = sentimentTotal > 0
+    ? [
+        { label: "Positive", count: stats.bySentiment.positive, color: sentimentColors.positive },
+        { label: "Neutral", count: stats.bySentiment.neutral, color: sentimentColors.neutral },
+        { label: "Negative", count: stats.bySentiment.negative, color: sentimentColors.negative },
+        { label: "Urgent", count: stats.bySentiment.urgent, color: sentimentColors.urgent },
+      ].filter((s) => s.count > 0)
+    : [];
+
+  const categoryEntries = Object.entries(stats.byCategory).sort(([, a], [, b]) => b - a);
+  const maxCategoryCount = categoryEntries.length > 0 ? categoryEntries[0][1] : 1;
+
+  return (
+    <div style={{ padding: 28, fontFamily: fontStack }}>
+      {/* Header */}
+      <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 24 }}>
+        <h1 style={{ fontFamily: displayFont, fontSize: 26, fontWeight: 600, margin: 0 }}>
+          Analytics
+        </h1>
+        <div style={{ display: "flex", gap: 6 }}>
+          {(["7d", "30d", "90d", "all"] as const).map((r) => (
+            <button
+              key={r}
+              onClick={() => setTimeRange(r)}
+              style={{
+                padding: "6px 14px",
+                borderRadius: 100,
+                fontSize: 12,
+                fontWeight: 600,
+                border: `1.5px solid ${timeRange === r ? theme.ink : theme.divider}`,
+                background: timeRange === r ? theme.ink : "#fff",
+                color: timeRange === r ? "#f8f6f1" : theme.ink,
+                cursor: "pointer",
+                fontFamily: fontStack,
+              }}
+            >
+              {r === "all" ? "All Time" : r.replace("d", " days")}
+            </button>
+          ))}
+        </div>
+      </div>
+
+      {/* Summary Cards */}
+      <div style={{ display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: 14, marginBottom: 28 }}>
+        {[
+          {
+            label: "Total Submissions",
+            value: stats.total,
+            sub: `${stats.byStatus.new + stats.byStatus.needs_reply} pending`,
+            color: stats.byStatus.needs_reply > 0 ? theme.accent : theme.muted,
+          },
+          {
+            label: "Resolution Rate",
+            value: `${stats.resolutionRate}%`,
+            sub: `${stats.byStatus.resolved + stats.byStatus.replied} resolved`,
+            color: stats.resolutionRate >= 80 ? "#059669" : stats.resolutionRate >= 50 ? "#d97706" : "#dc2626",
+          },
+          {
+            label: "Avg Sentiment",
+            value:
+              stats.avgSentiment !== null
+                ? stats.avgSentiment > 0.3
+                  ? "üëç Positive"
+                  : stats.avgSentiment < -0.3
+                  ? "üëé Negative"
+                  : "‚û°Ô∏è Neutral"
+                : "‚Äî",
+            sub:
+              stats.avgSentiment !== null
+                ? `Score: ${stats.avgSentiment.toFixed(2)}`
+                : "No data",
+            color: theme.muted,
+            small: true,
+          },
+          {
+            label: "Urgent Items",
+            value: stats.bySentiment.urgent,
+            sub: stats.bySentiment.urgent > 0 ? "Requires attention" : "All clear",
+            color: stats.bySentiment.urgent > 0 ? "#dc2626" : "#059669",
+          },
+        ].map((card, i) => (
+          <div
+            key={i}
+            style={{
+              background: "#fff",
+              borderRadius: 14,
+              padding: 18,
+              boxShadow: "0 1px 3px rgba(0,0,0,0.04)",
+              animation: `fadeUp 0.4s ease ${i * 0.06}s both`,
+            }}
+          >
+            <div style={{ fontSize: 11, fontWeight: 700, textTransform: "uppercase", letterSpacing: "0.06em", color: theme.muted }}>
+              {card.label}
+            </div>
+            <div style={{ fontFamily: card.small ? fontStack : displayFont, fontSize: card.small ? 18 : 30, color: theme.ink, marginTop: 2, fontWeight: card.small ? 700 : 400 }}>
+              {card.value}
+            </div>
+            <div style={{ fontSize: 11, color: card.color, fontWeight: 600, marginTop: 1 }}>
+              {card.sub}
+            </div>
+          </div>
+        ))}
+      </div>
+
+      {/* Trend Chart */}
+      <div
+        style={{
+          background: "#fff",
+          borderRadius: 16,
+          padding: 24,
+          marginBottom: 20,
+          boxShadow: "0 1px 3px rgba(0,0,0,0.04)",
+        }}
+      >
+        <h3 style={{ fontSize: 14, fontWeight: 700, color: theme.ink, margin: "0 0 18px", fontFamily: fontStack }}>
+          Submission Trend
+        </h3>
+        <div style={{ display: "flex", alignItems: "flex-end", gap: 2, height: 140 }}>
+          {trendData.map((d, i) => {
+            const barH = maxCount > 0 ? (d.count / maxCount) * 120 : 0;
+            const barColor =
+              d.sentiment > 0.3
+                ? "#059669"
+                : d.sentiment < -0.3
+                ? "#d97706"
+                : theme.primary;
+
+            // Show labels at intervals
+            const showLabel =
+              trendData.length <= 14 ||
+              i % Math.ceil(trendData.length / 10) === 0 ||
+              i === trendData.length - 1;
+
+            return (
+              <div
+                key={i}
+                style={{
+                  flex: 1,
+                  display: "flex",
+                  flexDirection: "column",
+                  alignItems: "center",
+                  gap: 4,
+                }}
+                title={`${d.label}: ${d.count} submission${d.count !== 1 ? "s" : ""}`}
+              >
+                <div
+                  style={{
+                    fontSize: 9,
+                    fontWeight: 600,
+                    color: theme.muted,
+                    opacity: d.count > 0 ? 1 : 0,
+                  }}
+                >
+                  {d.count}
+                </div>
+                <div
+                  style={{
+                    width: "100%",
+                    maxWidth: 24,
+                    height: Math.max(barH, d.count > 0 ? 4 : 1),
+                    background: d.count > 0 ? barColor : theme.divider,
+                    borderRadius: 3,
+                    transition: "height 0.3s ease",
+                    opacity: d.count > 0 ? 0.85 : 0.3,
+                  }}
+                />
+                <div
+                  style={{
+                    fontSize: 8,
+                    color: theme.muted,
+                    whiteSpace: "nowrap",
+                    opacity: showLabel ? 1 : 0,
+                  }}
+                >
+                  {d.label}
+                </div>
+              </div>
+            );
+          })}
+        </div>
+      </div>
+
+      {/* Two-column grid */}
+      <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 20, marginBottom: 20 }}>
+        {/* Sentiment Breakdown */}
+        <div
+          style={{
+            background: "#fff",
+            borderRadius: 16,
+            padding: 24,
+            boxShadow: "0 1px 3px rgba(0,0,0,0.04)",
+          }}
+        >
+          <h3 style={{ fontSize: 14, fontWeight: 700, color: theme.ink, margin: "0 0 18px", fontFamily: fontStack }}>
+            Sentiment Breakdown
+          </h3>
+          {sentimentSegments.length === 0 ? (
+            <div style={{ textAlign: "center", padding: 30, color: theme.muted, fontSize: 13 }}>
+              No sentiment data yet
+            </div>
+          ) : (
+            <div>
+              {/* Horizontal stacked bar */}
+              <div style={{ display: "flex", borderRadius: 8, overflow: "hidden", height: 28, marginBottom: 18 }}>
+                {sentimentSegments.map((seg) => (
+                  <div
+                    key={seg.label}
+                    style={{
+                      flex: seg.count,
+                      background: seg.color,
+                      opacity: 0.85,
+                      transition: "flex 0.3s ease",
+                    }}
+                    title={`${seg.label}: ${seg.count}`}
+                  />
+                ))}
+              </div>
+              {/* Legend */}
+              <div style={{ display: "flex", flexWrap: "wrap", gap: 14 }}>
+                {sentimentSegments.map((seg) => (
+                  <div key={seg.label} style={{ display: "flex", alignItems: "center", gap: 6 }}>
+                    <div style={{ width: 10, height: 10, borderRadius: 3, background: seg.color, opacity: 0.85 }} />
+                    <span style={{ fontSize: 12, color: theme.ink, fontWeight: 500 }}>{seg.label}</span>
+                    <span style={{ fontSize: 12, color: theme.muted }}>
+                      {seg.count} ({Math.round((seg.count / sentimentTotal) * 100)}%)
+                    </span>
+                  </div>
+                ))}
+              </div>
+              {stats.bySentiment.unanalyzed > 0 && (
+                <div style={{ fontSize: 11, color: theme.muted, marginTop: 10 }}>
+                  + {stats.bySentiment.unanalyzed} unanalyzed
+                </div>
+              )}
+            </div>
+          )}
+        </div>
+
+        {/* Category Distribution */}
+        <div
+          style={{
+            background: "#fff",
+            borderRadius: 16,
+            padding: 24,
+            boxShadow: "0 1px 3px rgba(0,0,0,0.04)",
+          }}
+        >
+          <h3 style={{ fontSize: 14, fontWeight: 700, color: theme.ink, margin: "0 0 18px", fontFamily: fontStack }}>
+            Category Distribution
+          </h3>
+          {categoryEntries.length === 0 ? (
+            <div style={{ textAlign: "center", padding: 30, color: theme.muted, fontSize: 13 }}>
+              No category data yet
+            </div>
+          ) : (
+            <div style={{ display: "flex", flexDirection: "column", gap: 10 }}>
+              {categoryEntries.map(([cat, count]) => (
+                <div key={cat}>
+                  <div style={{ display: "flex", justifyContent: "space-between", marginBottom: 4 }}>
+                    <span style={{ fontSize: 13, fontWeight: 500, color: theme.ink }}>{cat}</span>
+                    <span style={{ fontSize: 12, color: theme.muted }}>{count}</span>
+                  </div>
+                  <div style={{ background: theme.divider, borderRadius: 4, height: 8, overflow: "hidden" }}>
+                    <div
+                      style={{
+                        width: `${(count / maxCategoryCount) * 100}%`,
+                        height: "100%",
+                        background: theme.primary,
+                        borderRadius: 4,
+                        transition: "width 0.3s ease",
+                        opacity: 0.75,
+                      }}
+                    />
+                  </div>
+                </div>
+              ))}
+            </div>
+          )}
+        </div>
+      </div>
+
+      {/* Privacy Type Breakdown */}
+      <div
+        style={{
+          background: "#fff",
+          borderRadius: 16,
+          padding: 24,
+          boxShadow: "0 1px 3px rgba(0,0,0,0.04)",
+        }}
+      >
+        <h3 style={{ fontSize: 14, fontWeight: 700, color: theme.ink, margin: "0 0 18px", fontFamily: fontStack }}>
+          Privacy Mode Usage
+        </h3>
+        <div style={{ display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: 16 }}>
+          {([
+            { key: "identified", label: "Identified", icon: "üëã" },
+            { key: "anonymous", label: "Anonymous", icon: "üë§" },
+            { key: "relay", label: "Relay", icon: "üîÄ" },
+          ] as const).map((t) => {
+            const count = stats.byType[t.key];
+            const pct = stats.total > 0 ? Math.round((count / stats.total) * 100) : 0;
+            return (
+              <div
+                key={t.key}
+                style={{
+                  borderRadius: 12,
+                  padding: 16,
+                  border: `1.5px solid ${theme.divider}`,
+                  textAlign: "center",
+                }}
+              >
+                <div style={{ fontSize: 24, marginBottom: 4 }}>{t.icon}</div>
+                <div style={{ fontSize: 22, fontWeight: 700, color: typeColors[t.key], fontFamily: displayFont }}>
+                  {count}
+                </div>
+                <div style={{ fontSize: 11, color: theme.muted, fontWeight: 600, marginTop: 2 }}>
+                  {t.label} ¬∑ {pct}%
+                </div>
+              </div>
+            );
+          })}
+        </div>
+      </div>
+    </div>
+  );
+}
diff -ruN '--exclude=node_modules' '--exclude=.next' '--exclude=package-lock.json' a/components/FeedbackForm.tsx b/components/FeedbackForm.tsx
--- a/components/FeedbackForm.tsx	2026-02-17 16:38:20.000000000 +0000
+++ b/components/FeedbackForm.tsx	2026-02-18 23:25:09.000000000 +0000
@@ -53,19 +53,30 @@
     setSubmitting(true);
 
     try {
-      await submitFeedback(org.id, {
-        orgSlug: org.slug,
-        type: privacy,
-        categories: selectedCats,
-        text: feedback.trim(),
-        authorName: privacy === "identified" ? name.trim() : undefined,
-        authorEmail: privacy === "identified" ? email.trim() : undefined,
-        relayEmail: privacy === "relay" ? email.trim() : undefined,
+      const res = await fetch("/api/feedback", {
+        method: "POST",
+        headers: { "Content-Type": "application/json" },
+        body: JSON.stringify({
+          orgId: org.id,
+          orgSlug: org.slug,
+          type: privacy,
+          categories: selectedCats,
+          text: feedback.trim(),
+          authorName: privacy === "identified" ? name.trim() : undefined,
+          authorEmail: privacy === "identified" ? email.trim() : undefined,
+          relayEmail: privacy === "relay" ? email.trim() : undefined,
+        }),
       });
+
+      if (!res.ok) {
+        const data = await res.json().catch(() => ({}));
+        throw new Error(data.error || "Submission failed");
+      }
+
       setSubmitted(true);
-    } catch (err) {
+    } catch (err: any) {
       console.error("Submit failed:", err);
-      setError("Something went wrong. Please try again.");
+      setError(err.message || "Something went wrong. Please try again.");
     } finally {
       setSubmitting(false);
     }
